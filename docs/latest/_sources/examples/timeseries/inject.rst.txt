
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/timeseries/inject.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_timeseries_inject.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_timeseries_inject.py:


.. sectionauthor:: Alex Urban <alexander.urban@ligo.org>
.. currentmodule:: gwpy.timeseries

Inject a known signal into a `TimeSeries`
#########################################

It can often be useful to add some known signal to an inherently random
or noisy timeseries. For example, one might want to examine what
would happen if a binary black hole merger signal occured at or near
the time of a glitch. In LIGO data analysis, this procedure is referred
to as an *injection*.

In the example below, we will create a stream of random, white Gaussian
noise, then inject a simulation of GW150914 into it at a known time.

.. GENERATED FROM PYTHON SOURCE LINES 37-38

First, we prepare one second of Gaussian noise:

.. GENERATED FROM PYTHON SOURCE LINES 38-43

.. code-block:: Python


    from numpy import random
    from gwpy.timeseries import TimeSeries
    noise = TimeSeries(random.normal(scale=.1, size=16384), sample_rate=16384)








.. GENERATED FROM PYTHON SOURCE LINES 44-45

Then we can download a simulation of the GW150914 signal from GWOSC:

.. GENERATED FROM PYTHON SOURCE LINES 45-50

.. code-block:: Python


    url = "https://gwosc.org/s/events/GW150914/P150914/fig2-unfiltered-waveform-H.txt"
    signal = TimeSeries.read(url, format="txt")
    signal.t0 = .5  # make sure this intersects with noise time samples








.. GENERATED FROM PYTHON SOURCE LINES 51-55

Note, since this simulation cuts off before a certain time, it is
important to taper its ends to zero to avoid ringing artifacts.
We can accomplish this using the
:meth:`~gwpy.timeseries.TimeSeries.taper` method.

.. GENERATED FROM PYTHON SOURCE LINES 55-58

.. code-block:: Python


    signal = signal.taper()








.. GENERATED FROM PYTHON SOURCE LINES 59-61

Since the time samples overlap, we can inject this into our noise data
using :meth:`~gwpy.types.series.Series.inject`:

.. GENERATED FROM PYTHON SOURCE LINES 61-64

.. code-block:: Python


    data = noise.inject(signal)








.. GENERATED FROM PYTHON SOURCE LINES 65-66

Finally, we can visualize the full process in the time domain:

.. GENERATED FROM PYTHON SOURCE LINES 66-72

.. code-block:: Python


    from gwpy.plot import Plot
    plot = Plot(noise, signal, data, separate=True, sharex=True, sharey=True)
    plot.gca().set_epoch(0)
    plot.show()




.. image-sg:: /examples/timeseries/images/sphx_glr_inject_001.png
   :alt: inject
   :srcset: /examples/timeseries/images/sphx_glr_inject_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 73-75

We can clearly see that the loud GW150914-like signal has been layered
on top of Gaussian noise with the correct amplitude and phase evolution.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.339 seconds)


.. _sphx_glr_download_examples_timeseries_inject.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: inject.ipynb <inject.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: inject.py <inject.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: inject.zip <inject.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
